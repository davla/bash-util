#!/usr/bin/env bash

# This script downloads jetbrains IDEs in /opt/jetbrains
# directory, and proceeds with the launcher script then.
# Currently, only installing the latest version is supported,
# and only the following IDEs can be downloaded (it's just
# a matter of data-entry to add more):
#     - clion
#     - intellij
#     - goland
#     - pycharm
#     - rubymine
#     - webstorm

#####################################################
#
#                   Variables
#
#####################################################

ALLOWED_FLAVORS=''
HELP_MESSAGE="Usage install-jetbrains [-h] IDE_NAME [IDE_FLAVOR]

Where IDE_NAME is one of
    - clion
    - intellij
    - goland
    - pycharm
    - rubymine
    - webstorm

IDE_FLAVOR is optional, and is ignored for any value of IDE_NAME
other than 'intellij' and 'pycharm'. In such cases, it defaults
to 'community', but its possible values are:
    - 'community' or 'ultimate' if IDE_NAME is 'intellij'
    - 'community' or 'professional' if IDE_NAME is 'pycharm'

Options:
    -h      Prints this help message
"
IDE_CODE=''
JETBRAINS_BASE_DIR='/opt/jetbrains'
JETBRAINS_DOWNLOAD_URL='https://data.services.jetbrains.com/products/download'
PLATFORM='linux'
PLATFORM_SUFFIX=''

#####################################################
#
#                   Functions
#
#####################################################

# This function retruns the flavor component for the
# IDE code to submitted as a URL parameter.
#
# Arguments
#   -$1: The flavor whocse code shoudl be returned.
#   -$2: A space-separed list of allowed flavors.
function make-flavor-code {
    local FLAVOR="$1"
    local ALLOWED_FLAVORS="$2"

    read -a ALLOWED_FLAVORS <<<"$ALLOWED_FLAVORS"

    # Mock array-search -_-" - Printing on separate
    # lines and greping with line match.
    if printf '\n%s' ${ALLOWED_FLAVORS[@]} \
            | grep -x "$FLAVOR" > /dev/null; then
        awk '{print toupper(substr($0, 1, 1))}' <<<"$FLAVOR"
    else
        echo >&2 "Error: flavor '$FLAVOR' not recognized"
        exit 1
    fi
}

#####################################################
#
#               Input processing
#
#####################################################

while getopts 'h' OPTION; do
    case "$OPTION" in
        'h')
            echo -n "$HELP_MESSAGE"
            exit 0
            ;;

        *)  # getopts has already printed an error message
            echo -n "$HELP_MESSAGE"
            exit 1
            ;;
        esac
done
shift $(( OPTIND - 1 ))

IDE_NAME="${1,,}"

#####################################################
#
#               IDE-specific settings
#
#####################################################

case "$IDE_NAME" in
	'clion')
		IDE_CODE='CL'
		EXECPATH=bin/clion.sh
		;;

	'intellij')
        ALLOWED_FLAVORS='community ultimate'
        IDE_CODE='II'
        PLATFORM_SUFFIX='WithoutJDK'
		EXECPATH=bin/idea.sh
		;;

	'goland')
		IDE_CODE='GO'
		EXECPATH=bin/phpstorm.sh
		;;

	'phpstorm')
		IDE_CODE='PS'
		EXECPATH=bin/phpstorm.sh
		;;

	'pycharm')
        ALLOWED_FLAVORS='community professional'
        IDE_CODE='PC'
		EXECPATH=bin/pycharm.sh
		;;

	'rubymine')
		IDE_CODE='RM'
		EXECPATH=bin/rubymine.sh
		;;

	'webstorm')
		IDE_CODE='WS'
		EXECPATH=bin/webstorm.sh
		;;

	*)
		echo "IDE '$IDE_NAME' not recognized"
		exit 1
		;;
esac

URL_PLATFORM="${PLATFORM}${PLATFORM_SUFFIX}"

if [[ -n "$ALLOWED_FLAVORS" ]]; then
    FLAVOR="${2:-community}"

    # make-flavor-code prints an error message
    FLAVOR_CODE=$(make-flavor-code "$FLAVOR" "$ALLOWED_FLAVORS")
    [[ $? -ne 0 ]] && exit 1

    URL_CODE="${IDE_CODE}${FLAVOR_CODE}"
    FULL_IDE_NAME="$IDE_NAME-$FLAVOR"
else
    URL_CODE="$IDE_CODE"
    FULL_IDE_NAME="$IDE_NAME"
fi

#####################################################
#
#               Download and install
#
#####################################################

ARCH_NAME="$FULL_IDE_NAME.tar.gz"
IDE_BASE_DIR="$JETBRAINS_BASE_DIR/$FULL_IDE_NAME"

echo "Downoading $FULL_IDE_NAME..."
curl -GL "$JETBRAINS_DOWNLOAD_URL" \
    -d "platform=$URL_PLATFORM" \
    -d "code=$URL_CODE" \
    > "$ARCH_NAME"

# If jq parses without error, is a JSON response,
# tham means the HTTP request failed. This also
# prints the response in such case.
jq '.' "$ARCH_NAME" 2> /dev/null
[[ $? -eq 0 ]] && exit 1

sudo rm -rf "$IDE_BASE_DIR" 2> /dev/null
sudo mkdir -p "$IDE_BASE_DIR"

echo "Extracting $ARCH_NAME..."
sudo tar -xf "$ARCH_NAME" -C "$IDE_BASE_DIR" --strip-components=1

echo 'Launching installation script...'
"$IDE_BASE_DIR/$EXECPATH"

rm "$ARCH_NAME"
